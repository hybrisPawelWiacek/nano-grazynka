import { UseCase } from '../base/UseCase';
import { Result, NotFoundError, ValidationError } from '../base/Result';
import { VoiceNoteRepository } from '../../domain/repositories/VoiceNoteRepository';
import { VoiceNoteId } from '../../domain/value-objects/VoiceNoteId';

export interface ExportVoiceNoteInput {
  voiceNoteId: string;
  format?: 'markdown' | 'json';
  includeTranscription?: boolean;
  includeMetadata?: boolean;
}

export interface ExportVoiceNoteOutput {
  content: string;
  filename: string;
  mimeType: string;
}

export class ExportVoiceNoteUseCase extends UseCase<
  ExportVoiceNoteInput,
  Result<ExportVoiceNoteOutput>
> {
  constructor(
    private readonly voiceNoteRepository: VoiceNoteRepository
  ) {
    super();
  }

  async execute(input: ExportVoiceNoteInput): Promise<Result<ExportVoiceNoteOutput>> {
    try {
      // Find voice note
      const voiceNoteId = VoiceNoteId.fromString(input.voiceNoteId);
      const voiceNote = await this.voiceNoteRepository.findById(voiceNoteId);

      if (!voiceNote) {
        return {
          success: false,
          error: new NotFoundError(`Voice note with ID ${input.voiceNoteId} not found`)
        };
      }

      // Check if voice note has summary
      const summary = voiceNote.getSummary();
      if (!summary) {
        return {
          success: false,
          error: new ValidationError(
            'Cannot export: Voice note has not been processed yet. Please process it first.'
          )
        };
      }

      const format = input.format || 'markdown';
      let content: string;
      let filename: string;
      let mimeType: string;

      if (format === 'markdown') {
        content = this.generateMarkdown(voiceNote, input);
        filename = `${this.sanitizeFilename(voiceNote.getTitle())}.md`;
        mimeType = 'text/markdown';
      } else {
        content = this.generateJSON(voiceNote, input);
        filename = `${this.sanitizeFilename(voiceNote.getTitle())}.json`;
        mimeType = 'application/json';
      }

      return {
        success: true,
        data: {
          content,
          filename,
          mimeType
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new Error('Unknown error occurred')
      };
    }
  }

  private generateMarkdown(voiceNote: any, input: ExportVoiceNoteInput): string {
    const summary = voiceNote.getSummary();
    const transcription = voiceNote.getTranscription();
    
    let markdown = `# ${voiceNote.getTitle()}\n\n`;

    // Add metadata if requested
    if (input.includeMetadata) {
      markdown += `## Metadata\n\n`;
      markdown += `- **Date**: ${voiceNote.getCreatedAt().toISOString()}\n`;
      markdown += `- **Language**: ${voiceNote.getLanguage().getValue()}\n`;
      markdown += `- **Status**: ${voiceNote.getStatus().getValue()}\n`;
      if (voiceNote.getTags().length > 0) {
        markdown += `- **Tags**: ${voiceNote.getTags().join(', ')}\n`;
      }
      markdown += `\n`;
    }

    // Add summary
    markdown += `## Summary\n\n${summary.getSummary()}\n\n`;

    // Add key points
    if (summary.getKeyPoints().length > 0) {
      markdown += `## Key Points\n\n`;
      summary.getKeyPoints().forEach((point: string) => {
        markdown += `- ${point}\n`;
      });
      markdown += `\n`;
    }

    // Add action items
    if (summary.getActionItems().length > 0) {
      markdown += `## Action Items\n\n`;
      summary.getActionItems().forEach((item: any) => {
        let itemText = `- [ ] ${item.title}`;
        const metadata = [];
        if (item.owner) metadata.push(`Owner: ${item.owner}`);
        if (item.dueDate) metadata.push(`Due: ${item.dueDate}`);
        if (item.priority) metadata.push(`Priority: ${item.priority}`);
        if (item.project) metadata.push(`Project: ${item.project}`);
        
        if (metadata.length > 0) {
          itemText += ` (${metadata.join(', ')})`;
        }
        markdown += `${itemText}\n`;
      });
      markdown += `\n`;
    }

    // Add transcription if requested
    if (input.includeTranscription && transcription) {
      markdown += `## Transcription\n\n`;
      markdown += `${transcription.getText()}\n\n`;
    }

    // Add footer
    markdown += `---\n\n`;
    markdown += `*Generated by nano-Grazynka on ${new Date().toISOString()}*\n`;

    return markdown;
  }

  private generateJSON(voiceNote: any, input: ExportVoiceNoteInput): string {
    const summary = voiceNote.getSummary();
    const transcription = voiceNote.getTranscription();

    const data: any = {
      title: voiceNote.getTitle(),
      summary: {
        text: summary.getSummary(),
        keyPoints: summary.getKeyPoints(),
        actionItems: summary.getActionItems()
      }
    };

    // Add metadata if requested
    if (input.includeMetadata) {
      data.metadata = {
        id: voiceNote.getId().getValue(),
        createdAt: voiceNote.getCreatedAt().toISOString(),
        updatedAt: voiceNote.getUpdatedAt().toISOString(),
        language: voiceNote.getLanguage().getValue(),
        status: voiceNote.getStatus().getValue(),
        tags: voiceNote.getTags(),
        version: voiceNote.getVersion()
      };
    }

    // Add transcription if requested
    if (input.includeTranscription && transcription) {
      data.transcription = {
        text: transcription.getText(),
        timestamps: transcription.getTimestamps()
      };
    }

    data.exportedAt = new Date().toISOString();

    return JSON.stringify(data, null, 2);
  }

  private sanitizeFilename(title: string): string {
    // Remove or replace invalid filename characters
    return title
      .replace(/[^a-zA-Z0-9\s-_]/g, '')
      .replace(/\s+/g, '_')
      .substring(0, 100); // Limit length
  }
}