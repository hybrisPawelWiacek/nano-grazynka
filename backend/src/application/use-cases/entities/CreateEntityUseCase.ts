import { injectable, inject } from 'tsyringe';
import { IEntityRepository } from '../../../domain/repositories/IEntityRepository';
import { Entity } from '../../../domain/entities/Entity';

interface CreateEntityInput {
  userId: string;
  name: string;
  type: 'person' | 'company' | 'technical' | 'product';
  value: string;
  aliases?: string[];
  description?: string;
}

interface CreateEntityOutput {
  success: boolean;
  data?: {
    entity: Entity;
  };
  error?: Error;
}

@injectable()
export class CreateEntityUseCase {
  constructor(
    @inject('IEntityRepository') private entityRepository: IEntityRepository
  ) {}

  async execute(input: CreateEntityInput): Promise<CreateEntityOutput> {
    try {
      // Validate input
      if (!input.name || !input.type || !input.value || !input.userId) {
        throw new Error('Missing required fields: name, type, value, and userId are required');
      }

      // Validate type
      const validTypes = ['person', 'company', 'technical', 'product'];
      if (!validTypes.includes(input.type)) {
        throw new Error(`Invalid entity type. Must be one of: ${validTypes.join(', ')}`);
      }

      // Create entity domain object
      const entity = new Entity(
        '', // ID will be generated by repository
        input.userId,
        input.name,
        input.type,
        input.value,
        input.aliases,
        input.description,
        new Date(),
        new Date()
      );

      // Save to repository
      const savedEntity = await this.entityRepository.create(entity);

      return {
        success: true,
        data: {
          entity: savedEntity
        }
      };
    } catch (error) {
      console.error('[CreateEntityUseCase] Error creating entity:', error);
      return {
        success: false,
        error: error as Error
      };
    }
  }
}