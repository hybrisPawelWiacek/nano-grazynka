import { SummarizationService } from '../../domain/services/SummarizationService';
import { ConfigLoader } from '../../config/ConfigLoader';
import { CompositeObservabilityProvider } from '../observability/CompositeObservabilityProvider';

export interface SummarizationResult {
  summary: string;
  keyPoints: string[];
  actionItems: string[];
}

export class LLMAdapter implements SummarizationService {
  constructor(
    private config: ConfigLoader,
    private observability: CompositeObservabilityProvider
  ) {}

  async summarize(
    text: string,
    systemPrompt?: string,
    userPrompt?: string
  ): Promise<SummarizationResult> {
    const traceId = await this.observability.startTrace('llm.summarize', {
      textLength: text.length,
      hasSystemPrompt: !!systemPrompt,
      hasUserPrompt: !!userPrompt
    });

    try {
      // Stub implementation - in production would call OpenAI/Gemini API
      const mockResult: SummarizationResult = {
        summary: 'This is a mock summary of the transcribed text. In production, this would be generated by the LLM.',
        keyPoints: [
          'Key point 1: Important information discussed',
          'Key point 2: Action items identified',
          'Key point 3: Decisions made during the meeting'
        ],
        actionItems: [
          'Follow up with team on project status',
          'Schedule next meeting for review',
          'Send documentation to stakeholders'
        ]
      };
      
      await this.observability.endTrace(traceId, { success: true });
      return mockResult;
    } catch (error) {
      await this.observability.endTrace(traceId, null, error as Error);
      throw error;
    }
  }

  async classify(text: string, categories?: string[]): Promise<string> {
    const traceId = await this.observability.startTrace('llm.classify', {
      textLength: text.length,
      categoriesCount: categories?.length
    });

    try {
      // Stub implementation
      const classification = categories?.[0] || 'General';
      
      await this.observability.endTrace(traceId, { classification });
      return classification;
    } catch (error) {
      await this.observability.endTrace(traceId, null, error as Error);
      throw error;
    }
  }
}